{"meta":{"title":"Chris' Blog","subtitle":"learning by making","description":"Chris Tsui's personal blog, mainly about computer tech.","author":"Chris","url":"http://bensenq.github.io"},"pages":[],"posts":[{"title":"启航Docker","slug":"启航Docker","date":"2017-01-01T16:47:29.000Z","updated":"2017-01-01T16:59:36.589Z","comments":true,"path":"2017/01/02/启航Docker/","link":"","permalink":"http://bensenq.github.io/2017/01/02/启航Docker/","excerpt":"","text":"docker初试要了解一样东西，最简单的入门方法无非是去使用它，跟它交互，一步步填补概念和纠正已有认知。从今天开始踏上Docker之路！ 安装ubuntu 16.04上的安装还是比较方便的，根据官方文档，添加APT源，然后直接apt-get install docker-engine就ok了。具体命令如下：123456789$ sudo apt-get update$ sudo apt-get install apt-transport-https ca-certificates$ sudo apt-key adv \\ --keyserver hkp://ha.pool.sks-keyservers.net:80 \\ --recv-keys 58118E89F3A912897C070ADBF76221572C52609D$ echo \"deb https://apt.dockerproject.org/repo ubuntu-xenial main\" | sudo tee /etc/apt/sources.list.d/docker.list$ sudo apt-get update$ sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual$ sudo apt-get install docker-engine 小试开启docker服务docker daemon负责接收docker工具发过来的命令，然后做相应的操作，因此首先要开启它：1$ sudo service docker start hello worlddocker提供了一个最基本的hello world镜像，用来验证docker安装是否就绪。利用docker命令运行它：1$ sudo docker run hello-world 如果正常一切正常，应该有如下输出：12345678910111213141516171819Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker Hub account: https://hub.docker.comFor more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 可以看到，docker为了运行hello world例程，经过了一下几个步骤： Docker客户端（也就是Docker命令）连接Docker Daemon Docker Daemon从Docker Hub（也就是Docker应用仓库）中下载hello-world镜像 Docker Daemon根据hello-world镜像建立一个Container实例，该实例会运行可执行文件并输出上述打印 Docker Daemon把输出定向给Docker客户端，显示在终端 深入一点hello-world生命周期很短，输出消息后就退出了，看不到太多东东。根据上面的提示，我们可以在容器里运行个ubuntu镜像玩玩：1$ docker run -it ubuntu bash 其中-it是用来生成交互的伪终端与Container交互，ubuntu是镜像名。和hello-world例子不一样，这个例子多了参数bash，这是用来指明要在Docker中运行的进程，因此上面命令的意思是说，给我创建一个ubuntu容器，并运行bash shell。 如果不加结尾的bash，我们发现效果与bash相同，也就是说缺省情况下ubuntu镜像就会启动一个bash命令行. 把bash改成我们想要的命令，就可以在容器中运行它。换成ls试试：123 $ docker run -it ubuntu lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr 还可以给命令加参数：123456789101112131415161718192021$ sudo docker run -it ubuntu ls -lrttotal 64drwxr-xr-x 8 root root 4096 Sep 13 2015 libdrwxr-xr-x 2 root root 4096 Apr 12 2016 homedrwxr-xr-x 2 root root 4096 Apr 12 2016 bootdrwxr-xr-x 2 root root 4096 Dec 13 20:23 srvdrwxr-xr-x 2 root root 4096 Dec 13 20:23 optdrwxr-xr-x 2 root root 4096 Dec 13 20:23 mntdrwxr-xr-x 2 root root 4096 Dec 13 20:23 mediadrwxr-xr-x 2 root root 4096 Dec 13 20:24 lib64drwx------ 2 root root 4096 Dec 13 20:24 rootdrwxr-xr-x 2 root root 4096 Dec 13 20:24 bindrwxrwxrwt 2 root root 4096 Dec 13 20:24 tmpdrwxr-xr-x 11 root root 4096 Dec 15 17:45 usrdrwxr-xr-x 2 root root 4096 Dec 15 17:45 sbindrwxr-xr-x 13 root root 4096 Dec 15 17:45 vardrwxr-xr-x 6 root root 4096 Dec 15 17:45 rundr-xr-xr-x 13 root root 0 Dec 28 17:01 sysdrwxr-xr-x 45 root root 4096 Dec 28 17:35 etcdr-xr-xr-x 221 root root 0 Dec 28 17:35 procdrwxr-xr-x 5 root root 380 Dec 28 17:35 dev docker的容器本质上是提供了一个与主机环境隔离的执行环境，普通Linux上的1号进程是特殊的init，而容器环境下的1号进程就是启动容器时指定的应用。譬如，用ps命令试试看：123$ sudo docker run ubuntu:latest ps PID TTY TIME CMD 1 ? 00:00:00 ps 可以看到，ps命令在容器里的PID就是1。当然除了rootfs不同、进程PID编号不同，容器还在进程间通信、用户、文件系统挂载点、主机名称及物理资源（CPU、MEM、网络）等方面进行隔离和限制，后面逐步探索。","raw":null,"content":null,"categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://bensenq.github.io/tags/docker/"}]},{"title":"readl/raw_readl语义区别","slug":"raw_readl","date":"2016-08-27T09:25:42.000Z","updated":"2016-08-27T15:29:02.540Z","comments":true,"path":"2016/08/27/raw_readl/","link":"","permalink":"http://bensenq.github.io/2016/08/27/raw_readl/","excerpt":"","text":"进行Linux驱动方面开发的程序员，经常需要使用readl/writel系列函数对Memory-Mapped IO进行读写。那么readl/__readl/raw_readl/__raw_readl几个函数的具体语义有何差别呢？ 内核中关于这几个函数的说明非常有限，根据stackoverflow上的这个问答，我们可以总结为： raw前缀只与byteorder相关，即readl/writel是linux默认的小端操作，而raw_readl/raw_writel是native访问。也就是说：如果是小端系统，raw_readl与readl相同，如果是大端系统，raw_readl与readl的有字节序差别。 双下划线前缀与指令保序相关，即readl/writel包含存储器栅栏指令mb，能够保证IO读写顺序，而__readl/__writel则不能保证。 另外，有的体系结构还会定义readl_relaxed/writel_relaxed接口，其含义应该与__readl/__writel相同，表示小端、不带存储器栅栏的读写。","raw":null,"content":null,"categories":[],"tags":[{"name":"Kernel","slug":"Kernel","permalink":"http://bensenq.github.io/tags/Kernel/"}]},{"title":"GNU三元操作符扩展","slug":"GNU三元操作符扩展","date":"2016-03-03T14:12:29.000Z","updated":"2016-08-27T14:55:57.578Z","comments":true,"path":"2016/03/03/GNU三元操作符扩展/","link":"","permalink":"http://bensenq.github.io/2016/03/03/GNU三元操作符扩展/","excerpt":"","text":"Linux内核随处可见到关于三元操作符？:的这种使用方法： 1rdev-&gt;map_name = map_name ?: RC_MAP_EMPTY; 这是GNU C的关于标准C三元操作符?:的一个扩展，用来省略条件表达式的中间参数。也就是说，x ? : y 与 x ？ x : y完全等价。 所有GNU扩展都在GCC手册的Extensions to the C Language Family章节有详细描述。要注意，这些写法仅适合GCC编译器，如果要编写可移植的代码，那么就要格外小心。","raw":null,"content":null,"categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://bensenq.github.io/tags/C/"},{"name":"GNU","slug":"GNU","permalink":"http://bensenq.github.io/tags/GNU/"}]}]}